<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Force-Directed Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
    *      }

        .link {
            /*stroke: #999;*/
        }

        .node circle {
/*            stroke: #555;
            stroke-width: 1.5px;*/
        }

        .node text {
            font-size: 10px;
            font-family: sans-serif;
        }

        .tooltip {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            padding: 5px;
            border-radius: 5px;
            font-size: 12px;
            font-family: sans-serif;
            pointer-events: none;
            visibility: hidden;
        }

        .controls-container {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            padding: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-bottom: 1px solid #ddd;
            box-sizing: border-box;
        }

        .controls {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: sans-serif;
            font-size: 12px;
            box-sizing: border-box;
        }

        .text-box {
            margin-left: 10px;
            flex-grow: 1;
            background: rgba(245, 245, 245, 1);
            border: 1px solid #ddd;
            padding: 10px;
            font-family: sans-serif;
            font-size: 12px;
            line-height: 1.5;
            border-radius: 5px;
            height: fit-content;
            box-sizing: border-box;
        }

        svg {
            display: block;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div class="controls-container">
        <div class="controls">
            <div>
                <div class="slider-label">
                    <span>Link Distance</span><span id="linkDistanceValue">100</span>
                </div>
                <input type="range" id="linkDistance" min="5" max="500" step="5" value="100">
            </div>
            <div>
                <div class="slider-label">
                    <span>Charge Strength</span><span id="chargeStrengthValue">-100</span>
                </div>
                <input type="range" id="chargeStrength" min="-1000" max="0" step="20" value="-100">
            </div>
            <div>
                <div class="slider-label">
                    <span>Collision Radius</span><span id="collisionRadiusValue">50</span>
                </div>
                <input type="range" id="collisionRadius" min="5" max="500" step="5" value="50">
            </div>
        </div>
        <div class="text-box" id="textBox">
            Click on a node to see its details here.
        </div>
    </div>
    <div class="tooltip"></div>
    <svg></svg>
    <script>

        /**
 * Attempt to set a new x-position for `click_node` based on your rules.
 * 
 * @param {Object} click_node  The node datum the user clicked.
 * @param {Array} nodes        The array of all node data, each with { id, x, year, spineheld, ... }.
 * @param {Array} links        The array of all link data, each with { id, x, year, spineheld, ... }.
 * @param {Number} gridSize    The grid size or snap increment (for normal snapping).
 * @param {Number} TRACK_GAP   The time gap threshold to ensure no overlaps in years.
 */
        function setNodeXPosition(click_node, nodes, links, gridSize, TRACK_GAP) {
            // 1) Identify parents + children 
            const parentNodes = findParentNodes(click_node, nodes, links);   // Implement as needed
            const childNodes = findChildNodes(click_node, nodes, links);     // Implement as needed

            // 2) Filter those parents / children to the ones that are spineheld=1
            const heldParents = parentNodes.filter(p => p.spineheld === 1);
            const heldChildren = childNodes.filter(c => c.spineheld === 1);

            // 3) For each held parent, check viability
            const viableParents = [];
            for (let p of heldParents) {
                if (checkParentViability(click_node, p, nodes)) {
                    viableParents.push(p);
                }
            }

            // 4) For each held child, check viability
            const viableChildren = [];
            for (let c of heldChildren) {
                if (checkChildViability(click_node, c, nodes)) {
                    viableChildren.push(c);
                }
            }

            // 5) Decide how to set X based on your rules

            // => "no parent or child nodes are held: snap to position as currently"
            if (heldParents.length === 0 && heldChildren.length === 0) {
                snapToGrid(click_node, gridSize);
                return;
            }

            // => "no parent nodes held, viable child_nodes: place at the same x as one of viable child nodes"
            if (heldParents.length === 0 && viableChildren.length > 0) {
                // choose one child’s x, or pick the first
                const chosenChild = viableChildren[0];
                click_node.x = chosenChild.x;
                click_node.fx = chosenChild.x; // fix if desired
                return;
            }

            // => "no child nodes held, viable parent_nodes: place at the same x as one of viable parent nodes"
            if (heldChildren.length === 0 && viableParents.length > 0) {
                const chosenParent = viableParents[0];
                click_node.x = chosenParent.x;
                click_node.fx = chosenParent.x;
                return;
            }

            // => "viable child and parent nodes: check for a pair of child/parent nodes with the same x"
            if (viableChildren.length > 0 && viableParents.length > 0) {
                // find any matching X
                const childXs = viableChildren.map(c => c.x);
                // find a parent x that is in childXs
                const matchingParent = viableParents.find(p => childXs.includes(p.x));
                if (matchingParent) {
                    // set to that matching x
                    click_node.x = matchingParent.x;
                    click_node.fx = matchingParent.x;
                    return;
                } else {
                    // "If not set to the x of a viable parent node"
                    const chosenParent = viableParents[0];
                    click_node.x = chosenParent.x;
                    click_node.fx = chosenParent.x;
                    return;
                }
            }

            // => "all other cases: find a valid x where no other held nodes 
            //     have node_year within TRACK_GAP either side of click_node"
            const foundFreeX = findValidX(click_node, nodes, gridSize, TRACK_GAP);
            if (foundFreeX != null) {
                click_node.x = foundFreeX;
                click_node.fx = foundFreeX;
            } else {
                // fallback to normal grid snap
                snapToGrid(click_node, gridSize);
            }
        }

        /**
         * Example function to check if a 'parentNode' is viable for the 'click_node'.
         * This implements your logic:
         *   - "for each held parent_node: check if there is any other node (check_node) that:
         *        a) is not click_node
         *        b) is held
         *        c) has the same current x as the parent node
         *        d) has check_node_year < click_node_year
         *        e) has check_node_year > parent_node.year
         *      if yes => return false (inviable)
         *      if no => return true (viable)
         */
        function checkParentViability(click_node, parentNode, nodes) {
            for (let check_node of nodes) {
                if (
                    check_node !== click_node &&
                    check_node.spineheld === 1 &&
                    check_node.x === parentNode.x &&
                    check_node.year < click_node.year &&
                    check_node.year > parentNode.year
                ) {
                    return false; // inviability found
                }
            }
            return true; // no inviability found => viable
        }

        /**
         * Similar logic for child:
         *   - "check if there's any other node (check_node) that:
         *       a) is not click_node
         *       b) is held
         *       c) has the same current x as child_node
         *       d) check_node_year > click_node_year
         *       e) check_node_year < child_node.year
         *     if yes => return false
         *     if no => return true
         */
        function checkChildViability(click_node, childNode, nodes) {
            for (let check_node of nodes) {
                if (
                    check_node !== click_node &&
                    check_node.spineheld === 1 &&
                    check_node.x === childNode.x &&
                    check_node.year > click_node.year &&
                    check_node.year < childNode.year
                ) {
                    return false; // inviability
                }
            }
            return true;
        }

        /**
         * If no parent/child constraints apply, 
         * we pick an X that doesn't conflict with any held node whose year is within TRACK_GAP
         */
        function findValidX(click_node, nodes, gridSize, TRACK_GAP) {
            // Start from the current position (or snap it) 
            let potentialX = Math.round(click_node.x / gridSize) * gridSize;

            // In a real scenario, you might want to search left and right for an open slot.
            // For simplicity, let's just check the current snapped position for conflicts.
            const hasConflict = nodes.some(n => {
                if (n.spineheld === 1 && n !== click_node) {
                    // If the difference in years is < TRACK_GAP and the x is the same
                    if (Math.abs(n.year - click_node.year) < TRACK_GAP && n.x === potentialX) {
                        return true;
                    }
                }
                return false;
            });

            if (!hasConflict) {
                return potentialX;
            } else {
                // If there's a conflict, you could try shifting +/- 1 grid step,
                // or do a broader search. For now, let's just return null to fallback.
                return null;
            }
        }

        /** Simple helper to snap a node to the nearest grid increment. */
        function snapToGrid(node, gridSize) {
            const newX = Math.round(node.x / gridSize) * gridSize;
            node.x = newX;
            node.fx = newX;
        }

        /**
         * Finds all parent nodes of `click_node` by scanning `allLinks`.
         * 
         * "Parent" is defined as: 
         *   a node N where there is a link N → click_node.
         *   i.e. link.source.id === N.id && link.target.id === click_node.id
         *
         * @param {Object}  click_node  The node whose parents we want.
         * @param {Array}   allNodes    The entire array of node data.
         * @param {Array}   allLinks    The entire array of link data, each link having { source, target }.
         * @returns {Array} An array of node objects that are parents of `click_node`.
         */
        function findParentNodes(click_node, allNodes, allLinks) {
            // 1) Collect parent IDs by filtering links
            const parentIDs = allLinks
                .filter(link => link.target.id === click_node.id)
                .map(link => link.source.id);

            // 2) Return the actual parent node objects
            return allNodes.filter(n => parentIDs.includes(n.id));
        }

        /**
         * Finds all child nodes of `click_node` by scanning `allLinks`.
         * 
         * "Child" is defined as:
         *   a node N where there is a link click_node → N.
         *   i.e. link.source.id === click_node.id && link.target.id === N.id
         *
         * @param {Object}  click_node  The node whose children we want.
         * @param {Array}   allNodes    The entire array of node data.
         * @param {Array}   allLinks    The entire array of link data, each link having { source, target }.
         * @returns {Array} An array of node objects that are children of `click_node`.
         */
        function findChildNodes(click_node, allNodes, allLinks) {
            // 1) Collect child IDs by filtering links
            const childIDs = allLinks
                .filter(link => link.source.id === click_node.id)
                .map(link => link.target.id);

            // 2) Return the actual child node objects
            return allNodes.filter(n => childIDs.includes(n.id));
        }

        /**
 * Applies a style preset to a node with a given ID.
 * @param {String|Number} nodeId   The ID of the node you want to style
 * @param {String} styleCode       One of the keys in NODE_STYLES, e.g. "highlight", "incoming", etc.
 */
        function applyNodeStyle(nodeId, styleCode) {
            // 1) Get the style preset
            const stylePreset = NODE_STYLES[styleCode];
            if (!stylePreset) {
                console.warn(`No style preset found for code "${styleCode}". Skipping...`);
                return;
            }

            // 2) Select the node's circle by ID 
            //    (Adjust this if your data binding is different.)
            const circleSelection = d3.selectAll(".node")
                .filter(d => d.id === nodeId)
                .select("circle");

            // 3) Apply each attribute from stylePreset to the circle
            //    We check if the key is a valid attribute or style, 
            //    but simplest approach: just call .attr(...) for each.
            Object.entries(stylePreset).forEach(([attrName, attrValue]) => {
                circleSelection.attr(attrName, attrValue);
            });
        }

/** Applies a style preset to a node with a given ID.
 * @param { Object } focusLink   The ID of the node you want to style
 * @param { String } styleCode       One of the keys in NODE_STYLES, e.g. "highlight", "incoming", etc.
 */
        function applyLinkStyle(focusLinkData, styleCode) {
            // 1) Get the style preset
            const stylePreset = LINK_STYLES[styleCode];
            if (!stylePreset) {
                console.warn(`No style preset found for code "${styleCode}". Skipping...`);
                return;
            }

            // 2) Create a D3 selection by filtering on .link for the correct datum
            const linkSelection = d3.selectAll(".link")
                .filter(d => d === focusLinkData);

            // 3) Apply each attribute in the style preset to that selection
            Object.entries(stylePreset).forEach(([attrName, attrValue]) => {
                linkSelection.attr(attrName, attrValue);
            });
        }

        function recalcPositions(clickedNode) {
            // 1) Calculate new X for the clicked node
            //    (Replace with your own logic)
            const newX = Math.round(clickedNode.x / 200) * 200;

            // 2) Set the node’s x position, and optionally fix it
            clickedNode.x = newX;
            clickedNode.fx = newX; // If you want to “pin” the node

            // 3) Optionally update other nodes
            nodes.forEach(n => {
                // Example: Shift any spineheld=1 node 50 px to the right
                if (n.spineheld === 1) {
                    const shiftedX = n.x + 50;
                    n.x = shiftedX;
                    n.fx = shiftedX;
                }
            });

            // 4) Kick the simulation so changes take visible effect
            simulation.alpha(1).restart();
        }

        function adjustSVGHeight() {
            const controlsHeight = document.querySelector(".controls-container").offsetHeight;
            const svgWidth = window.innerWidth;
            const svgHeight = window.innerHeight - controlsHeight;

            d3.select("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight);

            return { svgWidth, svgHeight };
        }

        let { svgWidth, svgHeight } = adjustSVGHeight();

        const svg = d3.select("svg");
        const g = svg.append("g");
        const NODE_STYLES = {
            selected: {
                r: 6,
                "fill-opacity": 1,
                "stroke": "black",
                "stroke-width": 4,
                "stroke-opacity": 1
            },
            spine: {
                r: 6,
                "fill-opacity": 1,
                "stroke": "green",
                "stroke-width": 2,
                "stroke-opacity": 1
            },
            nonspine: {
                r: 6,
                "fill-opacity": 1,
                "stroke": "red",
                "stroke-width": 2,
                "stroke-opacity": 0.8
            },
            choice_in: {
                r: 8,
                /*                fill: "yellow",*/
                "fill-opacity": 1,
                "stroke": "black",
                "stroke-width": 6,
                "stroke-opacity": 0.3
            },
            choice_out: {
                r: 10,
                /*                fill: "yellow",*/
                "fill-opacity": 1,
                "stroke": "yellow",
                "stroke-width": 6,
                "stroke-opacity": 0.5
            },
            revealed: {
                r: 5,
                /*                fill: "yellow",*/
                "fill-opacity": 0.3,
                "stroke": "black",
                "stroke-width": 1,
                "stroke-opacity": 0.2
            },
            pool: {
                r: 3,
                "fill-opacity": 0.1,
                "stroke": "none"
            }
        };
        const LINK_STYLES = {
            spine: {
                "stroke": "black",
                "stroke-width": 2,
                "stroke-opacity": 0.8
            },
            spineadjacent: {
                "stroke": "black",
                "stroke-width": 5,
                "stroke-opacity": 0.3
            },
            general: {
                "stroke": "yellow",
                "stroke-width": 5,
                "stroke-opacity": 0.5
            },
            choice_in: {
                "stroke": "black",
                "stroke-width": 3,
                "stroke-opacity": 0.5
            },
            choice_out: {
                "stroke": "yellow",
                "stroke-width": 3,
                "stroke-opacity": 1
            },
            pool: {
                "stroke": "none"
            }
        };

        d3.json("mgpdata.json").then(graphData => {
            let nodes = graphData.nodes;
            let links = graphData.links;
            const all_nodes = graphData.nodes;
            const all_links = graphData.links;

            // Maintain lists for removed nodes and links
            let removedNodes = new Map(); // Key: Node ID, Value: Descendant nodes
            let removedLinks = new Map(); // Key: Node ID, Value: Descendant links

            // Initialize hidden state for nodes and links
            nodes.forEach(node => node.hidden = false);
            links.forEach(l => {
                l.hidden = false
                l.highlighted = false;
                l.highlightColor = null;
            });

            let linkDistance = 100;
            let chargeStrength = 0;
            let collisionRadius = 50;

            // Fix vertical positions and first node's x-axis
            nodes.forEach((d, i) => {
                //d.hidden = false;
                d.year = d.y;
                d.spine = 0;
                d.choice = 0;
                d.spineheld = 0;
                d.fixedY = svgHeight - ((d.y - 1660) / (2005 - 1660)) * svgHeight;
                d.fixedY = Math.max(10, Math.min(svgHeight - 10, d.fixedY));
                //d.attr("fill-opacity", 0.5);
                if (i === 0) {
                    d.fx = svgWidth / 2; // Fix X position
                    d.spine = 1;
                    d.spineheld = 1;
                }
            });

            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(linkDistance))
                .force("charge", d3.forceManyBody().strength(chargeStrength))
                .force("collision", d3.forceCollide().radius(collisionRadius))
                .on("tick", ticked);

            let link = g.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("class", "link")

                .attr("stroke-opacity", 0.2)
                .attr("spineheld", 0);

            let node = g.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(nodes)
                .enter().append("g")
                .attr("class", "node")
                .attr("fill-opacity", 0.2)
                .attr("stroke-opacity", 0.2);

            // Add drag behavior to nodes
            const drag = d3.drag()
                .on("start", dragStarted)
                .on("drag", dragged)
                .on("end", dragEnded);

            node.call(drag);

            // Update visibility of nodes and links
            function updateGraph() {
                // Update link visibility
                link
                    .style("visibility", d => (d.hidden ? "hidden" : "visible"));

                // Update node visibility
                node
                    .style("visibility", d => (d.hidden ? "hidden" : "visible"));
            }

            // Drag event handlers
            function dragStarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x; // Fix x position to enable dragging
            }

            function dragged(event, d) {
                d.fx = Math.max(10, Math.min(svgWidth - 10, event.x)); // Constrain to viewframe horizontally
                d.x = d.fx; // Update node's x position
            }

            function dragEnded(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = d.x; // Keep the node fixed in the dragged position
                d.fx = Math.round(d.x / 200) * 200;
            }

            node.append("circle")
                .attr("r", 5)
                .attr("fill", d => d.color)
                .on("mouseover", (event, d) => {
                    d3.select(".tooltip")
                        .style("visibility", "visible")
                        .style("top", `${event.pageY + 10}px`)
                        .style("left", `${event.pageX + 10}px`)
                        .html(`<strong>${d.name}</strong><br>${d.tooltip}`);
                })
                .on("mousemove", (event) => {
                    d3.select(".tooltip")
                        .style("top", `${event.pageY + 10}px`)
                        .style("left", `${event.pageX + 10}px`);
                })
                .on("mouseout", () => {
                    d3.select(".tooltip").style("visibility", "hidden");
                })

            // Add an event listener to reset formatting when clicking on empty space
            svg.on("click", () => {
                //resetFormatting();
            });
            // Double-click event handler
            //node.on("dblclick", (event, d) => {
            //    // Toggle visibility of outgoing nodes and links
            //    const hide = !d.hidden; // Toggle state

            //    // Recursive function to hide or show outgoing nodes/links
            //    function toggleOutgoing(node, hide) {
            //        node.hidden = hide;

            //        // Hide/show outgoing links
            //        links.forEach(link => {
            //            if (link.source.id === node.id) {
            //                link.hidden = hide;

            //                // Recursively hide/show target nodes
            //                const targetNode = nodes.find(n => n.id === link.target.id);
            //                if (targetNode) {
            //                    toggleOutgoing(targetNode, hide);
            //                }
            //            }
            //        });
            //    }

            //    toggleOutgoing(d, hide);

            //    // Update the graph
            //    updateGraph();
            //});

            // alt Double-click event handler2
            //node.on("dblclick", (event, d) => {
            //    if (d._descendantsRemoved) {
            //        // Restore descendants
            //        restoreDescendants(d);
            //    } else {
            //        // Remove descendants
            //        removeDescendants(d);
            //    }

            //    // Toggle the state
            //    d._descendantsRemoved = !d._descendantsRemoved;

            //    // Restart simulation
            //    restartSimulation();
            //});

            node.on("click", (event, d) => {
                // Reset formatting
                resetFormatting();

                if (d.spineheld === 0) {
                    setNodeXPosition(d, nodes, links, 200, 20); 
                }

                //fix position
                //d.fx = svgWidth / 2; // Fix X position
                //d.fx = Math.round(d.x / 200) * 200;
                d.spineheld = 1;



                d3.selectAll(".node")
                    .filter(n => n.id === d.id)
                    .append("text")
                    .attr("x", 9)
                    .attr("y", 3)
                    .text(n => n.name)
                    .attr("fill", "black")
                    .attr("fill-opacity", 1)
                    .style("font-size", "12px")
                    .style("font-weight", "bold"); // Bold text

                // Highlight the original clicked node
                d3.selectAll(".node")
                    .filter(n => n.id === d.id)
                    .select("circle")
                    .attr("r", 7)
                    .attr("fill-opacity", 0.898)
                    .attr("stroke-opacity", 1);

                applyNodeStyle(d.id, "selected");

                //highlighting for incoming nodes and links
                const visitedIncoming = new Set();
                function highlightIncoming(nodeId) {
                    if (visitedIncoming.has(nodeId)) return;
                    visitedIncoming.add(nodeId);

                    links.forEach(link => {
                        if (link.target.id === nodeId) {
                            // Highlight the incoming link
                            //d3.selectAll(".link")
                            //    .filter(l => l === link)
                            //    .attr("stroke", "red")
                            //    .attr("stroke-width", 3)
                            //    .attr("stroke-opacity", 1);

                            // Instead of directly .attr("stroke",...), store highlight state (CHANGED)
                            link.highlighted = true;
                            link.highlightColor = "red";

                            applyLinkStyle(link, "choice_in");

                            // Highlight the source node
                            d3.selectAll(".node")
                                .filter(n => n.id === link.source.id && link.source.spineheld === 0)
                                .select("circle")
                                .attr("r", 10);

                            applyNodeStyle(link.source.id, "choice_in");

                            //// Highlight any pickable nodes
                            //d3.selectAll(".node")
                            //    .filter(n => n.id === link.source.id)
                            //    .select("circle")
                            //    .attr("r", 10)
                            //// Recursively highlight incoming nodes
                            ////highlightIncoming(link.source.id);
                        }
                    });
                }

                // Recursive highlighting for outgoing nodes and links
                const visitedOutgoing = new Set();
                function highlightOutgoing(nodeId) {
                    if (visitedOutgoing.has(nodeId)) return;
                    visitedOutgoing.add(nodeId);

                    links.forEach(link => {
                        if (link.source.id === nodeId) {
                            // Highlight the outgoing link
                            //d3.selectAll(".link")
                            //    .filter(l => l === link)
                            //    .attr("stroke", "blue")
                            //    .attr("stroke-width", 3)
                            //    .attr("stroke-opacity", 1);

                            //// Store highlight state for the outgoing link (CHANGED)
                            link.highlighted = true;
                            link.highlightColor = "blue";

                            // Highlight the target node if unselected
                            d3.selectAll(".node")
                                .filter(n => n.id === link.target.id & link.target.spineheld === 0)
                                //.select("circle")
                                ////applyNodeStyle(n.id, "outgoing");
                                //.attr("r", 10);

                            applyNodeStyle(link.target.id, "choice_out");

                            //d3.selectAll(".node")
                            //    .filter(n => n.id === link.target.id)
                            //    .select("text")
                                //.attr("fill", "blue")
                                //.style("font-size", "14px");

                            // Recursively highlight outgoing nodes
                            //highlightOutgoing(link.target.id);
                        }

                     });
                }

                // Apply both recursive highlighting
                highlightIncoming(d.id);
                highlightOutgoing(d.id);


                // Update the text box with connected nodes
                const incomingLinks = links
                    .filter(link => link.target.id === d.id)
                    .map(link => `${link.source.id} (${Math.round(link.source.y)}) (A)`);

                const outgoingLinks = links
                    .filter(link => link.source.id === d.id)
                    .map(link => `${link.target.id} (${Math.round(link.target.y)}) (S)`);

                const textBoxContent = `
        <strong>Name:</strong> ${d.name}<br>
        <strong>Year:</strong> ${Math.round(d.year)}<br>
        <strong>Connected Nodes:</strong> ${[...incomingLinks, ...outgoingLinks].join(' ') || 'None'}<br>
        <strong>Summary:</strong> ${d.tooltip}
      `;

                d3.select("#textBox").html(textBoxContent);
            });

            node.on("dblclick", (event, d) => {

                // amend to force early exit
                //if (d.spineheld !== 1 && d.pickoption !== 1) {
                //    return;
                //}


                // Reset formatting
                resetFormatting();

                //fix position
                //d.fx = svgWidth / 2; // Fix X position
                d.fx = null
                d.spineheld = 1;

                // Highlight the original clicked node
                d3.selectAll(".node")
                    .filter(n => n.id === d.id)
                    .select("circle")
                    .attr("r", 7)
                    .attr("fill-opacity", 0.2)
                    .attr("stroke-opacity", 0.2)

                d3.selectAll(".node")
                    .filter(n => n.id === d.id)
                    .selectAll("text")
                    .remove();

                //highlighting for incoming nodes and links
                const visitedIncoming = new Set();
                function highlightIncoming(nodeId) {
                    if (visitedIncoming.has(nodeId)) return;
                    visitedIncoming.add(nodeId);

                    links.forEach(link => {
                        if (link.target.id === nodeId) {
                            // Highlight the incoming link
                            //d3.selectAll(".link")
                            //    .filter(l => l === link)
                            //    .attr("stroke", "red")
                            //    .attr("stroke-width", 3)
                            //    .attr("stroke-opacity", 1);

                            // Instead of directly .attr("stroke",...), store highlight state (CHANGED)
                            link.highlighted = false;
                            link.highlightColor = "red";

                            // Highlight the source node
                            d3.selectAll(".node")
                                .filter(n => n.id === link.source.id)
                                .select("circle")
                                .attr("r", 10);;

                            // Recursively highlight incoming nodes
                            //highlightIncoming(link.source.id);
                        }
                    });
                }

                // Recursive highlighting for outgoing nodes and links
                const visitedOutgoing = new Set();
                function highlightOutgoing(nodeId) {
                    if (visitedOutgoing.has(nodeId)) return;
                    visitedOutgoing.add(nodeId);

                    links.forEach(link => {
                        if (link.source.id === nodeId) {
                            // Highlight the outgoing link
                            //d3.selectAll(".link")
                            //    .filter(l => l === link)
                            //    .attr("stroke", "blue")
                            //    .attr("stroke-width", 3)
                            //    .attr("stroke-opacity", 1);

                            //// Store highlight state for the outgoing link (CHANGED)
                            link.highlighted = false;
                            link.highlightColor = "blue";

                            // Highlight the target node if unselected
                            d3.selectAll(".node")
                                .filter(n => n.id === link.target.id)
                                .select("circle")
                                .attr("r", 10);

                            d3.selectAll(".node")
                                .filter(n => n.id === link.target.id)
                                .select("text")
                            //.attr("fill", "blue")
                            //.style("font-size", "14px");

                            // Recursively highlight outgoing nodes
                            //highlightOutgoing(link.target.id);
                        }

                    });
                }

                // Apply both recursive highlighting
                highlightIncoming(d.id);
                highlightOutgoing(d.id);


                // Update the text box with connected nodes
                const incomingLinks = links
                    .filter(link => link.target.id === d.id)
                    .map(link => `${link.source.id} (${Math.round(link.source.y)}) (A)`);

                const outgoingLinks = links
                    .filter(link => link.source.id === d.id)
                    .map(link => `${link.target.id} (${Math.round(link.target.y)}) (S)`);

                const textBoxContent = `
  <strong>Name:</strong> ${d.name}<br>
  <strong>Year:</strong> ${Math.round(d.year)}<br>
  <strong>Connected Nodes:</strong> ${[...incomingLinks, ...outgoingLinks].join(' ') || 'None'}<br>
  <strong>Summary:</strong> ${d.tooltip}
`;

                d3.select("#textBox").html(textBoxContent);
            });



            // Function to reset all formatting
            function resetFormatting() {
                links.forEach(l => {
                    if (l.source.spineheld === 1 && l.target.spineheld === 1) {
                        // Skip clearing highlight
                        return;
                    }
                    // Otherwise, reset highlight
                    l.highlighted = false;
                    l.highlightColor = null;
                });

                nodes.forEach(resetnode => {
                    if (resetnode.spineheld === 0) {
                        applyNodeStyle(resetnode.id, "pool");
                    }
                    if (resetnode.spineheld === 1) {
                        applyNodeStyle(resetnode.id, "selected");
                    }
                });

                d3.selectAll(".link")
                    //.attr("stroke-opacity", 0);  // or 0.2 if you want a faint default

                //d3.selectAll(".node circle")
                //    .attr("stroke", "none");
            }





            // Remove descendants
            function removeDescendants(node) {
                const descendants = new Set();
                const linksToRemove = [];
                const nodesToRemove = [];

                function findDescendants(nodeId) {
                    links.forEach(link => {
                        if (link.source.id === nodeId) {
                            descendants.add(link.target.id);
                            linksToRemove.push(link);

                            // Recursively find further descendants
                            findDescendants(link.target.id);
                        }
                    });
                }

                findDescendants(node.id);

                // Collect descendant nodes
                descendants.forEach(descendantId => {
                    const descendantNode = nodes.find(n => n.id === descendantId);
                    if (descendantNode) nodesToRemove.push(descendantNode);
                });

                // Save removed nodes and links
                removedNodes.set(node.id, nodesToRemove);
                removedLinks.set(node.id, linksToRemove);

                // Update the graph data
                nodes.splice(0, nodes.length, ...nodes.filter(n => !descendants.has(n.id)));
                links.splice(0, links.length, ...links.filter(l => !linksToRemove.includes(l)));
                //nodes = nodes.filter(n => !descendants.has(n.id));
                //links = links.filter(l => !linksToRemove.includes(l));
            }

            function restoreDescendants(node) {
                const nodesToRestore = removedNodes.get(node.id) || [];
                const linksToRestore = removedLinks.get(node.id) || [];

                // Add back the removed nodes and links
                nodes.push(...nodesToRestore);
                links.push(...linksToRestore);

                // Clean up the temporary storage
                removedNodes.delete(node.id);
                removedLinks.delete(node.id);
            }

            // Restart simulation
            function restartSimulation() {
                // Rebind links
                link = g.selectAll(".link")
                    .data(links, d => `${d.source.id}-${d.target.id}`);

                link.exit().remove(); // Remove exiting links
                link.enter()
                    .append("line")
                    .attr("class", "link")
                    .merge(link);
                        


                // Rebind nodes
                node = g.selectAll(".node")
                    .data(nodes, d => d.id);

                node.exit().remove(); // Remove exiting nodes

                const nodeEnter = node.enter()
                    .append("g")
                    .attr("class", "node")
                    .call(drag);

                nodeEnter.append("circle")
                    .attr("r", 5)
                    .attr("fill", d => d.color);

                //nodeEnter.append("text")
                //    .attr("x", 9)
                //    .attr("y", 3)
                //    .text(d => d.id);

                node = nodeEnter.merge(node);

                simulation.nodes(nodes);
                simulation.force("link").links(links);
                simulation.alpha(1).restart();
            }
            function ticked() {
                // Constrain nodes horizontally, fix vertical position
                nodes.forEach(d => {
                    d.x = Math.max(10, Math.min(svgWidth - 10, d.x)); // Horizontal bounds
                });

                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.fixedY)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.fixedY)
                //.style("visibility", d => "visible")); // Update visibility
                                        // Use data-driven stroke color/opacity (ADDED)
                    //.attr("stroke", d => d.highlighted ? d.highlightColor : "#999")
                    .attr("stroke-width", d => d.highlighted ? 3 : 1.5)
                    .attr("stroke-opacity", d => d.highlighted ? 1 : 0.2);

                node
                    .attr("transform", d => `translate(${d.x},${d.fixedY})`);

            }

            d3.select("#linkDistance").on("input", function () {
                linkDistance = +this.value;
                d3.select("#linkDistanceValue").text(linkDistance);
                simulation.force("link", d3.forceLink(links).id(d => d.id).distance(linkDistance));
                simulation.alpha(1).restart();
            });

            d3.select("#chargeStrength").on("input", function () {
                chargeStrength = +this.value;
                d3.select("#chargeStrengthValue").text(chargeStrength);
                simulation.force("charge", d3.forceManyBody().strength(chargeStrength));
                simulation.alpha(1).restart();
            });

            d3.select("#collisionRadius").on("input", function () {
                collisionRadius = +this.value;
                d3.select("#collisionRadiusValue").text(collisionRadius);
                simulation.force("collision", d3.forceCollide().radius(collisionRadius));
                simulation.alpha(1).restart();
            });
        }).catch(error => console.error(error));
    </script>
</body>
</html>
