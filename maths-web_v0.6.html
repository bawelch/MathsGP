<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Force-Directed Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        .link {
            stroke: #999;
        }

        .node circle {
            stroke: #555;
            stroke-width: 1.5px;
        }

        .node text {
            font-size: 10px;
            font-family: sans-serif;
        }

        .tooltip {
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            padding: 5px;
            border-radius: 5px;
            font-size: 12px;
            font-family: sans-serif;
            pointer-events: none;
            visibility: hidden;
        }

        .controls-container {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            padding: 10px;
            background: rgba(255, 255, 255, 0.9);
            border-bottom: 1px solid #ddd;
            box-sizing: border-box;
        }

        .controls {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-family: sans-serif;
            font-size: 12px;
            box-sizing: border-box;
        }

        .text-box {
            margin-left: 10px;
            flex-grow: 1;
            background: rgba(245, 245, 245, 1);
            border: 1px solid #ddd;
            padding: 10px;
            font-family: sans-serif;
            font-size: 12px;
            line-height: 1.5;
            border-radius: 5px;
            height: fit-content;
            box-sizing: border-box;
        }

        svg {
            display: block;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div class="controls-container">
        <div class="controls">
            <div>
                <div class="slider-label">
                    <span>Link Distance</span><span id="linkDistanceValue">100</span>
                </div>
                <input type="range" id="linkDistance" min="5" max="500" step="5" value="100">
            </div>
            <div>
                <div class="slider-label">
                    <span>Charge Strength</span><span id="chargeStrengthValue">-100</span>
                </div>
                <input type="range" id="chargeStrength" min="-1000" max="0" step="20" value="-100">
            </div>
            <div>
                <div class="slider-label">
                    <span>Collision Radius</span><span id="collisionRadiusValue">50</span>
                </div>
                <input type="range" id="collisionRadius" min="5" max="500" step="5" value="50">
            </div>
        </div>
        <div class="text-box" id="textBox">
            Click on a node to see its details here.
        </div>
    </div>
    <div class="tooltip"></div>
    <svg></svg>
    <script>

        /**
 * Applies a style preset to a node with a given ID.
 * @param {String|Number} nodeId   The ID of the node you want to style
 * @param {String} styleCode       One of the keys in NODE_STYLES, e.g. "highlight", "incoming", etc.
 */
        function applyNodeStyle(nodeId, styleCode) {
            // 1) Get the style preset
            const stylePreset = NODE_STYLES[styleCode];
            if (!stylePreset) {
                console.warn(`No style preset found for code "${styleCode}". Skipping...`);
                return;
            }

            // 2) Select the node's circle by ID 
            //    (Adjust this if your data binding is different.)
            const circleSelection = d3.selectAll(".node")
                .filter(d => d.id === nodeId)
                .select("circle");

            // 3) Apply each attribute from stylePreset to the circle
            //    We check if the key is a valid attribute or style, 
            //    but simplest approach: just call .attr(...) for each.
            Object.entries(stylePreset).forEach(([attrName, attrValue]) => {
                circleSelection.attr(attrName, attrValue);
            });
        }


        function adjustSVGHeight() {
            const controlsHeight = document.querySelector(".controls-container").offsetHeight;
            const svgWidth = window.innerWidth;
            const svgHeight = window.innerHeight - controlsHeight;

            d3.select("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight);

            return { svgWidth, svgHeight };
        }

        let { svgWidth, svgHeight } = adjustSVGHeight();

        const svg = d3.select("svg");
        const g = svg.append("g");
        const NODE_STYLES = {
            selected: {
                r: 15,
                //fill: "yellow",
                "fill-opacity": 1
                //"stroke": "black",
                //"stroke-width": 2
            },
            choice: {
                r: 15,
/*                fill: "yellow",*/
                "fill-opacity": 1,
                "stroke": "black",
                "stroke-width": 5,
                "stroke-opacity": 0.5
            },
            incoming: {
                r: 80,
/*                fill: "red",*/
                "fill-opacity": 0.9
            },
            outgoing: {
                r: 15,
/*                fill: "blue",*/
                "fill-opacity": 0.9
            },
            normal: {
                r: 5,
                //fill: "gray",
                "fill-opacity": 0.2
/*                stroke: "none"*/
            }
            // ... add as many presets as you want
        };
        const LINK_STYLES = {
            spine: {
                r: 15,
                //fill: "yellow",
                "fill-opacity": 1
                //"stroke": "black",
                //"stroke-width": 2
            },
            choice_in: {
                r: 15,
                /*                fill: "yellow",*/
                "fill-opacity": 1
                //"stroke": "black",
                //"stroke-width": 2
            },
            choice_out: {
                r: 80,
                /*                fill: "red",*/
                "fill-opacity": 0.9
            },
            linked: {
                r: 15,
                /*                fill: "blue",*/
                "fill-opacity": 0.9
            },
            hidden: {
                r: 5,
                //fill: "gray",
                "stroke-opacity": 0
                /*                stroke: "none"*/
            }
            // ... add as many presets as you want
        };

        d3.json("mgpdata.json").then(graphData => {
            let nodes = graphData.nodes;
            let links = graphData.links;
            const all_nodes = graphData.nodes;
            const all_links = graphData.links;

            // Maintain lists for removed nodes and links
            let removedNodes = new Map(); // Key: Node ID, Value: Descendant nodes
            let removedLinks = new Map(); // Key: Node ID, Value: Descendant links

            // Initialize hidden state for nodes and links
            nodes.forEach(node => node.hidden = false);
            links.forEach(l => {
                l.hidden = false
                l.highlighted = false;
                l.highlightColor = null;
            });

            let linkDistance = 100;
            let chargeStrength = 0;
            let collisionRadius = 50;

            // Fix vertical positions and first node's x-axis
            nodes.forEach((d, i) => {
                //d.hidden = false;
                d.year = d.y;
                d.spine = 0;
                d.choice = 0;
                d.spinelock = 0;
                d.fixedY = svgHeight - ((d.y - 1660) / (2005 - 1660)) * svgHeight;
                d.fixedY = Math.max(10, Math.min(svgHeight - 10, d.fixedY));
                //d.attr("fill-opacity", 0.5);
                if (i === 0) {
                    d.fx = svgWidth / 2; // Fix X position
                    d.spine = 1;
                    d.spinelock = 1;
                }
            });

            const simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(linkDistance))
                .force("charge", d3.forceManyBody().strength(chargeStrength))
                .force("collision", d3.forceCollide().radius(collisionRadius))
                .on("tick", ticked);

            let link = g.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("class", "link")
                .attr("stroke-opacity", 0.2)
                .attr("spinelock", 0);

            let node = g.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(nodes)
                .enter().append("g")
                .attr("class", "node")
                .attr("fill-opacity", 0.2)
                .attr("stroke-opacity", 0.2);

            // Add drag behavior to nodes
            const drag = d3.drag()
                .on("start", dragStarted)
                .on("drag", dragged)
                .on("end", dragEnded);

            node.call(drag);

            // Update visibility of nodes and links
            function updateGraph() {
                // Update link visibility
                link
                    .style("visibility", d => (d.hidden ? "hidden" : "visible"));

                // Update node visibility
                node
                    .style("visibility", d => (d.hidden ? "hidden" : "visible"));
            }

            // Drag event handlers
            function dragStarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x; // Fix x position to enable dragging
            }

            function dragged(event, d) {
                d.fx = Math.max(10, Math.min(svgWidth - 10, event.x)); // Constrain to viewframe horizontally
                d.x = d.fx; // Update node's x position
            }

            function dragEnded(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = d.x; // Keep the node fixed in the dragged position
                d.fx = Math.round(d.x / 200) * 200;
            }

            node.append("circle")
                .attr("r", 5)
                .attr("fill", d => d.color)
                .on("mouseover", (event, d) => {
                    d3.select(".tooltip")
                        .style("visibility", "visible")
                        .style("top", `${event.pageY + 10}px`)
                        .style("left", `${event.pageX + 10}px`)
                        .html(`<strong>${d.name}</strong><br>${d.tooltip}`);
                })
                .on("mousemove", (event) => {
                    d3.select(".tooltip")
                        .style("top", `${event.pageY + 10}px`)
                        .style("left", `${event.pageX + 10}px`);
                })
                .on("mouseout", () => {
                    d3.select(".tooltip").style("visibility", "hidden");
                })

            // Add an event listener to reset formatting when clicking on empty space
            svg.on("click", () => {
                //resetFormatting();
            });
            // Double-click event handler
            //node.on("dblclick", (event, d) => {
            //    // Toggle visibility of outgoing nodes and links
            //    const hide = !d.hidden; // Toggle state

            //    // Recursive function to hide or show outgoing nodes/links
            //    function toggleOutgoing(node, hide) {
            //        node.hidden = hide;

            //        // Hide/show outgoing links
            //        links.forEach(link => {
            //            if (link.source.id === node.id) {
            //                link.hidden = hide;

            //                // Recursively hide/show target nodes
            //                const targetNode = nodes.find(n => n.id === link.target.id);
            //                if (targetNode) {
            //                    toggleOutgoing(targetNode, hide);
            //                }
            //            }
            //        });
            //    }

            //    toggleOutgoing(d, hide);

            //    // Update the graph
            //    updateGraph();
            //});

            // alt Double-click event handler2
            //node.on("dblclick", (event, d) => {
            //    if (d._descendantsRemoved) {
            //        // Restore descendants
            //        restoreDescendants(d);
            //    } else {
            //        // Remove descendants
            //        removeDescendants(d);
            //    }

            //    // Toggle the state
            //    d._descendantsRemoved = !d._descendantsRemoved;

            //    // Restart simulation
            //    restartSimulation();
            //});

            node.on("click", (event, d) => {
                // Reset formatting
                resetFormatting();

                //fix position
                //d.fx = svgWidth / 2; // Fix X position
                d.fx = Math.round(d.x / 200) * 200;
                d.spinelock = 1;



                d3.selectAll(".node")
                    .filter(n => n.id === d.id)
                    .append("text")
                    .attr("x", 9)
                    .attr("y", 3)
                    .text(n => n.name)
                    .attr("fill", "black")
                    .attr("fill-opacity", 1)
                    .style("font-size", "12px")
                    .style("font-weight", "bold"); // Bold text

                // Highlight the original clicked node
                d3.selectAll(".node")
                    .filter(n => n.id === d.id)
                    .select("circle")
                    .attr("r", 7)
                    .attr("fill-opacity", 0.898)
                    .attr("stroke-opacity", 1);

                applyNodeStyle(d.id, "selected");

                //highlighting for incoming nodes and links
                const visitedIncoming = new Set();
                function highlightIncoming(nodeId) {
                    if (visitedIncoming.has(nodeId)) return;
                    visitedIncoming.add(nodeId);

                    links.forEach(link => {
                        if (link.target.id === nodeId) {
                            // Highlight the incoming link
                            //d3.selectAll(".link")
                            //    .filter(l => l === link)
                            //    .attr("stroke", "red")
                            //    .attr("stroke-width", 3)
                            //    .attr("stroke-opacity", 1);

                            // Instead of directly .attr("stroke",...), store highlight state (CHANGED)
                            link.highlighted = true;
                            link.highlightColor = "red";

                            // Highlight the source node
                            d3.selectAll(".node")
                                .filter(n => n.id === link.source.id && link.source.spinelock === 0)
                                .select("circle")
                                .attr("r", 10);

                            applyNodeStyle(link.source.id, "incoming");

                            //// Highlight any pickable nodes
                            //d3.selectAll(".node")
                            //    .filter(n => n.id === link.source.id)
                            //    .select("circle")
                            //    .attr("r", 10)
                            //// Recursively highlight incoming nodes
                            ////highlightIncoming(link.source.id);
                        }
                    });
                }

                // Recursive highlighting for outgoing nodes and links
                const visitedOutgoing = new Set();
                function highlightOutgoing(nodeId) {
                    if (visitedOutgoing.has(nodeId)) return;
                    visitedOutgoing.add(nodeId);

                    links.forEach(link => {
                        if (link.source.id === nodeId) {
                            // Highlight the outgoing link
                            //d3.selectAll(".link")
                            //    .filter(l => l === link)
                            //    .attr("stroke", "blue")
                            //    .attr("stroke-width", 3)
                            //    .attr("stroke-opacity", 1);

                            //// Store highlight state for the outgoing link (CHANGED)
                            link.highlighted = true;
                            link.highlightColor = "blue";

                            // Highlight the target node if unselected
                            d3.selectAll(".node")
                                .filter(n => n.id === link.target.id & link.target.spinelock === 0)
                                .select("circle")
                                //applyNodeStyle(n.id, "outgoing");
                                .attr("r", 10);
                                

                            //d3.selectAll(".node")
                            //    .filter(n => n.id === link.target.id)
                            //    .select("text")
                                //.attr("fill", "blue")
                                //.style("font-size", "14px");

                            // Recursively highlight outgoing nodes
                            //highlightOutgoing(link.target.id);
                        }

                     });
                }

                // Apply both recursive highlighting
                highlightIncoming(d.id);
                highlightOutgoing(d.id);


                // Update the text box with connected nodes
                const incomingLinks = links
                    .filter(link => link.target.id === d.id)
                    .map(link => `${link.source.id} (${Math.round(link.source.y)}) (A)`);

                const outgoingLinks = links
                    .filter(link => link.source.id === d.id)
                    .map(link => `${link.target.id} (${Math.round(link.target.y)}) (S)`);

                const textBoxContent = `
        <strong>Name:</strong> ${d.name}<br>
        <strong>Year:</strong> ${Math.round(d.year)}<br>
        <strong>Connected Nodes:</strong> ${[...incomingLinks, ...outgoingLinks].join(' ') || 'None'}<br>
        <strong>Summary:</strong> ${d.tooltip}
      `;

                d3.select("#textBox").html(textBoxContent);
            });

            node.on("dblclick", (event, d) => {

                // amend to force early exit
                //if (d.spinelock !== 1 && d.pickoption !== 1) {
                //    return;
                //}


                // Reset formatting
                resetFormatting();

                //fix position
                //d.fx = svgWidth / 2; // Fix X position
                d.fx = null
                d.spinelock = 1;

                // Highlight the original clicked node
                d3.selectAll(".node")
                    .filter(n => n.id === d.id)
                    .select("circle")
                    .attr("r", 7)
                    .attr("fill-opacity", 0.2)
                    .attr("stroke-opacity", 0.2)

                d3.selectAll(".node")
                    .filter(n => n.id === d.id)
                    .selectAll("text")
                    .remove();

                //highlighting for incoming nodes and links
                const visitedIncoming = new Set();
                function highlightIncoming(nodeId) {
                    if (visitedIncoming.has(nodeId)) return;
                    visitedIncoming.add(nodeId);

                    links.forEach(link => {
                        if (link.target.id === nodeId) {
                            // Highlight the incoming link
                            //d3.selectAll(".link")
                            //    .filter(l => l === link)
                            //    .attr("stroke", "red")
                            //    .attr("stroke-width", 3)
                            //    .attr("stroke-opacity", 1);

                            // Instead of directly .attr("stroke",...), store highlight state (CHANGED)
                            link.highlighted = false;
                            link.highlightColor = "red";

                            // Highlight the source node
                            d3.selectAll(".node")
                                .filter(n => n.id === link.source.id)
                                .select("circle")
                                .attr("r", 10);;

                            // Recursively highlight incoming nodes
                            //highlightIncoming(link.source.id);
                        }
                    });
                }

                // Recursive highlighting for outgoing nodes and links
                const visitedOutgoing = new Set();
                function highlightOutgoing(nodeId) {
                    if (visitedOutgoing.has(nodeId)) return;
                    visitedOutgoing.add(nodeId);

                    links.forEach(link => {
                        if (link.source.id === nodeId) {
                            // Highlight the outgoing link
                            //d3.selectAll(".link")
                            //    .filter(l => l === link)
                            //    .attr("stroke", "blue")
                            //    .attr("stroke-width", 3)
                            //    .attr("stroke-opacity", 1);

                            //// Store highlight state for the outgoing link (CHANGED)
                            link.highlighted = false;
                            link.highlightColor = "blue";

                            // Highlight the target node if unselected
                            d3.selectAll(".node")
                                .filter(n => n.id === link.target.id)
                                .select("circle")
                                .attr("r", 10);

                            d3.selectAll(".node")
                                .filter(n => n.id === link.target.id)
                                .select("text")
                            //.attr("fill", "blue")
                            //.style("font-size", "14px");

                            // Recursively highlight outgoing nodes
                            //highlightOutgoing(link.target.id);
                        }

                    });
                }

                // Apply both recursive highlighting
                highlightIncoming(d.id);
                highlightOutgoing(d.id);


                // Update the text box with connected nodes
                const incomingLinks = links
                    .filter(link => link.target.id === d.id)
                    .map(link => `${link.source.id} (${Math.round(link.source.y)}) (A)`);

                const outgoingLinks = links
                    .filter(link => link.source.id === d.id)
                    .map(link => `${link.target.id} (${Math.round(link.target.y)}) (S)`);

                const textBoxContent = `
  <strong>Name:</strong> ${d.name}<br>
  <strong>Year:</strong> ${Math.round(d.year)}<br>
  <strong>Connected Nodes:</strong> ${[...incomingLinks, ...outgoingLinks].join(' ') || 'None'}<br>
  <strong>Summary:</strong> ${d.tooltip}
`;

                d3.select("#textBox").html(textBoxContent);
            });



            // Function to reset all formatting
            function resetFormatting() {
                links.forEach(l => {
                    if (l.source.spinelock === 1 && l.target.spinelock === 1) {
                        // Skip clearing highlight
                        return;
                    }
                    // Otherwise, reset highlight
                    l.highlighted = false;
                    l.highlightColor = null;
                });

                //nodes.forEach(resetnode => {
                //    if (resetnode.spinelock === 0) {
                //        applyNodeStyle(resetnode.id, "normal");
                //    }
                //});

                d3.selectAll(".link")
                    //.attr("stroke-opacity", 0);  // or 0.2 if you want a faint default

                d3.selectAll(".node circle")
                    .attr("stroke", "none");
            }





            // Remove descendants
            function removeDescendants(node) {
                const descendants = new Set();
                const linksToRemove = [];
                const nodesToRemove = [];

                function findDescendants(nodeId) {
                    links.forEach(link => {
                        if (link.source.id === nodeId) {
                            descendants.add(link.target.id);
                            linksToRemove.push(link);

                            // Recursively find further descendants
                            findDescendants(link.target.id);
                        }
                    });
                }

                findDescendants(node.id);

                // Collect descendant nodes
                descendants.forEach(descendantId => {
                    const descendantNode = nodes.find(n => n.id === descendantId);
                    if (descendantNode) nodesToRemove.push(descendantNode);
                });

                // Save removed nodes and links
                removedNodes.set(node.id, nodesToRemove);
                removedLinks.set(node.id, linksToRemove);

                // Update the graph data
                nodes.splice(0, nodes.length, ...nodes.filter(n => !descendants.has(n.id)));
                links.splice(0, links.length, ...links.filter(l => !linksToRemove.includes(l)));
                //nodes = nodes.filter(n => !descendants.has(n.id));
                //links = links.filter(l => !linksToRemove.includes(l));
            }

            function restoreDescendants(node) {
                const nodesToRestore = removedNodes.get(node.id) || [];
                const linksToRestore = removedLinks.get(node.id) || [];

                // Add back the removed nodes and links
                nodes.push(...nodesToRestore);
                links.push(...linksToRestore);

                // Clean up the temporary storage
                removedNodes.delete(node.id);
                removedLinks.delete(node.id);
            }

            // Restart simulation
            function restartSimulation() {
                // Rebind links
                link = g.selectAll(".link")
                    .data(links, d => `${d.source.id}-${d.target.id}`);

                link.exit().remove(); // Remove exiting links
                link.enter()
                    .append("line")
                    .attr("class", "link")
                    .merge(link);
                        


                // Rebind nodes
                node = g.selectAll(".node")
                    .data(nodes, d => d.id);

                node.exit().remove(); // Remove exiting nodes

                const nodeEnter = node.enter()
                    .append("g")
                    .attr("class", "node")
                    .call(drag);

                nodeEnter.append("circle")
                    .attr("r", 5)
                    .attr("fill", d => d.color);

                //nodeEnter.append("text")
                //    .attr("x", 9)
                //    .attr("y", 3)
                //    .text(d => d.id);

                node = nodeEnter.merge(node);

                simulation.nodes(nodes);
                simulation.force("link").links(links);
                simulation.alpha(1).restart();
            }
            function ticked() {
                // Constrain nodes horizontally, fix vertical position
                nodes.forEach(d => {
                    d.x = Math.max(10, Math.min(svgWidth - 10, d.x)); // Horizontal bounds
                });

                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.fixedY)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.fixedY)
                //.style("visibility", d => "visible")); // Update visibility
                                        // Use data-driven stroke color/opacity (ADDED)
                    //.attr("stroke", d => d.highlighted ? d.highlightColor : "#999")
                    .attr("stroke-width", d => d.highlighted ? 3 : 1.5)
                    .attr("stroke-opacity", d => d.highlighted ? 1 : 0.2);

                node
                    .attr("transform", d => `translate(${d.x},${d.fixedY})`);

            }

            d3.select("#linkDistance").on("input", function () {
                linkDistance = +this.value;
                d3.select("#linkDistanceValue").text(linkDistance);
                simulation.force("link", d3.forceLink(links).id(d => d.id).distance(linkDistance));
                simulation.alpha(1).restart();
            });

            d3.select("#chargeStrength").on("input", function () {
                chargeStrength = +this.value;
                d3.select("#chargeStrengthValue").text(chargeStrength);
                simulation.force("charge", d3.forceManyBody().strength(chargeStrength));
                simulation.alpha(1).restart();
            });

            d3.select("#collisionRadius").on("input", function () {
                collisionRadius = +this.value;
                d3.select("#collisionRadiusValue").text(collisionRadius);
                simulation.force("collision", d3.forceCollide().radius(collisionRadius));
                simulation.alpha(1).restart();
            });
        }).catch(error => console.error(error));
    </script>
</body>
</html>
