<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Force-Directed Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
          body {
              margin: 0;
              overflow: hidden;
          }

          .link {
              /*stroke: #999;*/
          }

          .node circle {
              /*stroke: #555;
        stroke-width: 1.5px;*/
          }

          .node text {
              font-size: 10px;
              font-family: sans-serif;
          }

          .tooltip {
              position: absolute;
              background-color: white;
              border: 1px solid #ccc;
              padding: 5px;
              border-radius: 5px;
              font-size: 12px;
              font-family: sans-serif;
              pointer-events: none;
              visibility: hidden;
          }

          .controls-container {
              display: flex;
              flex-direction: row;
              align-items: flex-start;
              padding: 10px;
              background: rgba(255, 255, 255, 0.9);
              border-bottom: 1px solid #ddd;
              box-sizing: border-box;
          }

          .controls {
              background: rgba(255, 255, 255, 0.9);
              padding: 10px;
              border: 1px solid #ddd;
              border-radius: 5px;
              font-family: sans-serif;
              font-size: 12px;
              box-sizing: border-box;
          }

          .text-box {
              margin-left: 10px;
              flex-grow: 1;
              background: rgba(245, 245, 245, 1);
              border: 1px solid #ddd;
              padding: 10px;
              font-family: sans-serif;
              font-size: 12px;
              line-height: 1.5;
              border-radius: 5px;
              height: fit-content;
              box-sizing: border-box;
          }

          svg {
              display: block;
              box-sizing: border-box;
          }
    </style>
</head>
<body>
    <!-- Controls and Info Panel -->
    <div class="controls-container">
        <div class="controls">
            <div>
                <div class="slider-label">
                    <span>Link Distance</span>
                    <span id="linkDistanceValue">100</span>
                </div>
                <input type="range" id="linkDistance" min="5" max="500" step="5" value="100" />
            </div>
            <div>
                <div class="slider-label">
                    <span>Charge Strength</span>
                    <span id="chargeStrengthValue">-100</span>
                </div>
                <input type="range" id="chargeStrength" min="-1000" max="0" step="20" value="-100" />
            </div>
            <div>
                <div class="slider-label">
                    <span>Collision Radius</span>
                    <span id="collisionRadiusValue">50</span>
                </div>
                <input type="range" id="collisionRadius" min="5" max="500" step="5" value="50" />
            </div>
        </div>
        <div class="text-box" id="textBox">
            Click on a node to see its details here.
        </div>
    </div>

    <!-- Tooltip -->
    <div class="tooltip"></div>

    <!-- Main SVG Container -->
    <svg></svg>

    <script>
        /***************************************************************
         * 1) HELPER FUNCTIONS & UTILITIES
         ***************************************************************/

        /**
         * Dynamically adjusts the SVG size based on the controls panel height.
         * @returns {Object} { svgWidth, svgHeight }
         */
        function adjustSVGHeight() {
            const controlsHeight = document.querySelector(".controls-container").offsetHeight;
            const svgWidth = window.innerWidth;
            const baseBufferHeight = 50
            const svgHeight = window.innerHeight - controlsHeight-baseBufferHeight;

            d3.select("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight);

            return { svgWidth, svgHeight };
        }

        /**
         * Snaps a node's x-coordinate to the given grid size.
         */
        function snapToGrid(node, gridSize) {
            const newX = Math.round(node.x / gridSize) * gridSize;
            node.x = newX;
            node.fx = newX;
        }

        /**
         * Finds all parent nodes of `click_node` by scanning the links.
         * "Parent" is where link.source.id === parent's ID and link.target.id === click_node.id
         */
        function findParentNodes(click_node, allNodes, allLinks) {
            const parentIDs = allLinks
                .filter(link => link.target.id === click_node.id)
                .map(link => link.source.id);
            return allNodes.filter(n => parentIDs.includes(n.id));
        }

        /**
         * Finds all child nodes of `click_node` by scanning the links.
         * "Child" is where link.source.id === click_node.id and link.target.id === child's ID
         */
        function findChildNodes(click_node, allNodes, allLinks) {
            const childIDs = allLinks
                .filter(link => link.source.id === click_node.id)
                .map(link => link.target.id);
            return allNodes.filter(n => childIDs.includes(n.id));
        }

        /**
         * Checks if a parent node is viable, per your rules:
         * - Must not find another held node with the same x, whose year is between parent.year and click_node.year.
         */
        function checkParentViability(click_node, parentNode, nodes) {
            for (let check_node of nodes) {
                if (
                    check_node !== click_node &&
                    check_node.spineheld === 1 &&
                    check_node.x === parentNode.x &&
                    check_node.year > parentNode.year
                ) {
                    return false; // inviability found
                }
            }
            return true;
        }

        /**
         * Checks if a child node is viable, per your rules:
         * - Must not find another held node with the same x, whose year is between click_node.year and childNode.year.
         */
        function checkChildViability(click_node, childNode, nodes) {
            for (let check_node of nodes) {
                if (
                    check_node !== click_node &&
                    check_node.spineheld === 1 &&
                    check_node.x === childNode.x &&
                    check_node.year < childNode.year
                ) {
                    return false; // inviability found
                }
            }
            return true;
        }


        /**
 /**
 * Attempts to find a valid X coordinate for `click_node` under different "modes."
 *
 * modes:
 *  -1:  Directly compute a "nearby" snap to click_node.x
 *   0:  Search outward from the center of the window
 *   1:  Search outward from the average (center of mass) of `syncNodes`
 *
 * @param {Object}  click_node  The node we're repositioning.
 * @param {Array}   nodes       All node data.
 * @param {Array}   syncNodes   Subset of nodes for "center of mass" in mode=1.
 * @param {Number}  gridSize    The snapping increment for X.
 * @param {Number}  TRACK_GAP   The year proximity threshold for conflicts.
 * @param {Number}  mode_id     The mode to use: -1, 0, or 1.
 * @returns {Number|null}       A valid X or null if none found.
 */
        function findValidX(click_node, nodes, syncNodes, gridSize, TRACK_GAP, mode_id) {
            // Helper to check if a given X conflicts with any other spineheld node
            function hasConflictAt(xValue) {
                return nodes.some(n => {
                    if (n.spineheld === 1 && n !== click_node) {
                        const closeInYear = Math.abs(n.year - click_node.year) < TRACK_GAP;
                        const sameX = (n.x === xValue);
                        if (closeInYear && sameX) {
                            return true;
                        }
                    }
                    return false;
                });
            }

            // Initialize result and possibly conflict
            let potentialX = null;

            if (mode_id === -1) {
                // 1) Snap to the nearest grid from click_node.x
                potentialX = Math.round(click_node.x / gridSize) * gridSize;

                // Check conflict
                const conflict = hasConflictAt(potentialX);
                return conflict ? null : potentialX;

            } else if (mode_id === 0) {
                // 2) Find any viable spot "center out" from window center
                //    We'll check positions around centerX in a do/while.

                let centreX = Math.round(window.innerWidth / gridSize) * gridSize;
                let direction = 1;
                let left = 1;
                let right = 1;
                let count = 2;

                // If the center is beyond the window, reverse direction
                if (centreX > window.innerWidth) {
                    direction = -1;
                }

                // We'll try positions: centreX, centreX +/- gridSize, etc.
                do {
                    const trialPosition = centreX + direction * Math.floor(count / 2) * gridSize;

                    // Check if within window bounds
                    if (trialPosition < 0) {
                        left = 0;
                    } else if (trialPosition > window.innerWidth) {
                        right = 0;
                    } else {
                        // Check conflict
                        if (!hasConflictAt(trialPosition)) {
                            return trialPosition;
                        }
                    }

                    count++;
                    // Flip direction after each increment, e.g. +, -, +, -
                    direction *= -1;

                } while (left > 0 || right > 0);

                // If no position found
                return null;

            } else if (mode_id === 1) {
                // 3) Find viable spot center-out from the "center of mass" of syncNodes
                //    If no syncNodes, fallback logic can go here.

                if (!syncNodes || syncNodes.length === 0) {
                    return null;
                }

                // Average X of syncNodes
                let position_sum = 0;
                let count_syncs = 0;

                syncNodes.forEach(sync_node => {
                    position_sum += sync_node.x;
                    count_syncs++;
                });

                const centreX = Math.round((position_sum / count_syncs) / gridSize) * gridSize;

                let direction = 1;
                let left = 1;
                let right = 1;
                let count = 2;

                if (centreX > window.innerWidth) {
                    direction = -1;
                }

                do {
                    const trialPosition = centreX + direction * Math.floor(count / 2) * gridSize;

                    if (trialPosition < 0) {
                        left = 0;
                    } else if (trialPosition > window.innerWidth) {
                        right = 0;
                    } else {
                        if (!hasConflictAt(trialPosition)) {
                            return trialPosition;
                        }
                    }

                    count++;
                    // Flip direction after each increment
                    direction *= -1;

                } while (left > 0 || right > 0);

                return null;
            }

            // If mode_id wasn't -1,0,1, or no valid X was found
            return null;
        }



        //function findValidX(click_node, nodes, gridSize, TRACK_GAP) {
        //    const potentialX = Math.round(click_node.x / gridSize) * gridSize;
        //    const hasConflict = nodes.some(n => {
        //        if (n.spineheld === 1 && n !== click_node) {
        //            const closeInYear = Math.abs(n.year - click_node.year) < TRACK_GAP;
        //            const sameX = n.x === potentialX;
        //            if (closeInYear && sameX) return true;
        //        }
        //        return false;
        //    });

        //    return hasConflict ? null : potentialX;
        //}

        /**
         * Searches for an x-position that doesn't conflict with any held node if
         * their year is within TRACK_GAP of click_node.year.
        // */
        //function findValidX(click_node, nodes, syncNodes, gridSize, TRACK_GAP, mode_id) {

        //    const left = 1;
        //    const right = 1;

        //    if (mode_id === -1) {
        //        // find any viable spot near click
        //        const potentialX = Math.round(click_node.x / gridSize) * gridSize;
        //        const hasConflict = nodes.some(n => {
        //            if (n.spineheld === 1 && n !== click_node) {
        //                const closeInYear = Math.abs(n.year - click_node.year) < TRACK_GAP;
        //                const sameX = n.x === potentialX;
        //                if (closeInYear && sameX) return true;
        //            }
        //            return false;
        //        });
        //    }
        //    else if (mode_id === 0) {
        //        // find any viable spot centre out

        //        // set centre spot
        //        const centreX = Math.round(window.innerWidth / gridSize) * gridSize;
        //        const direction = 1;
        //        count = 2

        //        if (centreX > window.innerwidth) {
        //            direction = -1;
        //        }

        //        do {
        //            const trialPosition = centreX + direction * math.floor(count / 2) * gridSize
        //            if (trialPosition < 0) {
        //                left = 0;
        //            }
        //            else if (trialPositon > window.innerwidth) {
        //                right = 0;
        //            }
        //            else {
        //                const hasConflict = nodes.some(n => {
        //                    if (n.spineheld === 1 && n !== click_node) {
        //                        const closeInYear = Math.abs(n.year - click_node.year) < TRACK_GAP;
        //                        const sameX = n.x === trialPosition;
        //                        if (closeInYear && sameX) return true;
        //                    }
        //                    return false;
        //                });

        //                if (hasConflict === false) { return trialPosition }
        //            }
        //        } while ((left > 0 || right > 0)) 
        //    }
        //    else if (mode_id == 1) {
        //        // find viable spot centre out from sync node centre of mass

        //        const position_sum = 0;
        //        const count_syncs = 0;
        //        for (let sync_node of syncNodes) {
        //            position_sum += sync_node.x;
        //            count_syncs++;
        //        }

        //        const centreX = Math.round((position_sum/count_syncs) / gridSize) * gridSize;
        //        const direction = 1;
        //        count = 2

        //        if (centreX > window.innerwidth) {
        //            direction = -1;
        //        }

        //        do {
        //            const trialPosition = centreX + direction * math.floor(count / 2) * gridSize
        //            if (trialPosition < 0) {
        //                left = 0;
        //            }
        //            else if (trialPositon > window.innerwidth) {
        //                right = 0;
        //            }
        //            else {
        //                const hasConflict = nodes.some(n => {
        //                    if (n.spineheld === 1 && n !== click_node) {
        //                        const closeInYear = Math.abs(n.year - click_node.year) < TRACK_GAP;
        //                        const sameX = n.x === trialPosition;
        //                        if (closeInYear && sameX) return true;
        //                    }
        //                    return false;
        //                });

        //                if (hasConflict === false) { return trialPosition }
        //            }
        //        } while ((left > 0 || right > 0)) 


        //    }

        //    return hasConflict ? null : potentialX;
        //}

        /**
         * Sets the node's x-position based on parent/child viability checks.
         * Follows your multi-step logic to handle parents, children, fallback, etc.
         */
        function setNodeXPosition(click_node, nodes, links, gridSize, TRACK_GAP) {
            // Identify parents and children
            const parentNodes = findParentNodes(click_node, nodes, links);
            const childNodes = findChildNodes(click_node, nodes, links);

            // Filter out the ones that are spineheld=1
            const heldParents = parentNodes.filter(p => p.spineheld === 1);
            const heldChildren = childNodes.filter(c => c.spineheld === 1);

            // Check viability for each held parent
            const viableParents = [];
            for (let p of heldParents) {
                if (checkParentViability(click_node, p, nodes)) {
                    viableParents.push(p);
                }
            }

            // Check viability for each held child
            const viableChildren = [];
            for (let c of heldChildren) {
                if (checkChildViability(click_node, c, nodes)) {
                    viableChildren.push(c);
                }
            }

            // Decision logic

            // 1 -  no attached parent or child nodes
            if (heldParents.length === 0 && heldChildren.length === 0) {
                // No held parents/children => normal snap
                // adjust to snap to the closest available to centre
                snapToGrid(click_node, gridSize);
                return;
            }

            // 2 - no attached parent, at least one viable child - snap to oldest(?) child
            if (heldParents.length === 0 && viableChildren.length > 0) {
                // No held parents, but viable children => use a child's x
                const chosenChild = viableChildren[0];
                click_node.x = chosenChild.x;
                click_node.fx = chosenChild.x;
                return;
            }

            // 3 - no attached child, at least one viable child - snape to oldest(?) parent
            if (heldChildren.length === 0 && viableParents.length > 0) {
                // No held children, but viable parents => use a parent's x
                const chosenParent = viableParents[0];
                click_node.x = chosenParent.x;
                //moveNodeToX(click_node, chosenParent.x, 0.03, 2000);
                click_node.fx = chosenParent.x;
                return;
            }

            // 4 - viable parent and child connections
            if (viableChildren.length > 0 && viableParents.length > 0) {
                // Both child & parent => look for matching x
                const childXs = viableChildren.map(c => c.x);
                const matchingParent = viableParents.find(p => childXs.includes(p.x));

                // aim for directions
                if (matchingParent) {
                    click_node.x = matchingParent.x;
                    click_node.fx = matchingParent.x;
                } else {
                    // fallback: viable parent x
                    const chosenParent = viableParents[0];
                    click_node.x = chosenParent.x;
                    click_node.fx = chosenParent.x;
                }
                return;
            }

            // 5 - No spot ahead of attached parent, no children
            if (heldChildren.length === 0 && viableParents.length === 0 && heldParents.length > 0) {
                const foundFreeX = findValidX(click_node, nodes, heldParents, gridSize, TRACK_GAP,1);
                if (foundFreeX != null) {
                    click_node.x = foundFreeX;
                    click_node.fx = foundFreeX;

                // aim for directions
                if (matchingParent) {
                    click_node.x = matchingParent.x;
                    click_node.fx = matchingParent.x;
                } else {
                    // fallback: viable parent x
                    const chosenParent = viableParents[0];
                    click_node.x = chosenParent.x;
                    click_node.fx = chosenParent.x;
                }
                return;
            }

            // Otherwise: find a free x
            const foundFreeX = findValidX(click_node, nodes, heldParents, gridSize, TRACK_GAP,0);
            if (foundFreeX != null) {
                click_node.x = foundFreeX;
                click_node.fx = foundFreeX;
            } else {
                snapToGrid(click_node, gridSize);
            }
        }

        /**
         * Applies a style preset to a node with a given ID.
         * @param {String|Number} nodeId  The node ID
         * @param {String} styleCode      Key from NODE_STYLES
         */
        function applyNodeStyle(nodeId, styleCode) {
            const stylePreset = NODE_STYLES[styleCode];
            if (!stylePreset) {
                console.warn(`No style preset found for code "${styleCode}". Skipping...`);
                return;
            }

            const circleSelection = d3.selectAll(".node")
                .filter(d => d.id === nodeId)
                .select("circle");

            Object.entries(stylePreset).forEach(([attrName, attrValue]) => {
                circleSelection.attr(attrName, attrValue);
            });
        }

        /**
         * Applies a style preset to a link (by datum).
         * @param {Object} focusLinkData  The link datum
         * @param {String} styleCode      Key from LINK_STYLES
         */
        function applyLinkStyle(focusLinkData, styleCode) {
            const stylePreset = LINK_STYLES[styleCode];
            if (!stylePreset) {
                console.warn(`No style preset found for code "${styleCode}". Skipping...`);
                return;
            }

            const linkSelection = d3.selectAll(".link")
                .filter(d => d === focusLinkData);

            Object.entries(stylePreset).forEach(([attrName, attrValue]) => {
                linkSelection.attr(attrName, attrValue);
            });
        }

        /**
         * Example function that repositions a clicked node (and shifts spineheld=1 nodes by +50).
         */
        function recalcPositions(clickedNode) {
            const newX = Math.round(clickedNode.x / 200) * 200;
            clickedNode.x = newX;
            clickedNode.fx = newX;

            nodes.forEach(n => {
                if (n.spineheld === 1) {
                    const shiftedX = n.x + 50;
                    n.x = shiftedX;
                    n.fx = shiftedX;
                }
            });

            simulation.alpha(1).restart();
        }
        /**
 * Finds all unique paths in a directed graph (defined by `nodes` and `links`)
 * from `sourceId` to `targetId`, moving only from parent -> child (i.e., link.source -> link.target).
 * 
 * @param {Array} nodes - Array of node objects, each with a unique `id`.
 * @param {Array} links - Array of link objects, each with `.source.id` and `.target.id`.
 * @param {String|Number} sourceId - The ID of the start node.
 * @param {String|Number} targetId - The ID of the end node.
 * @returns {Array} A list of paths, where each path is an array of node IDs.
 */
        function findAllPaths(nodes, links, sourceId, targetId) {
            // 1) Build an adjacency map: nodeId -> array of child nodeIds
            //    so we can easily look up the "children" of a node.
            const adjacency = buildAdjacencyMap(nodes, links);

            const allPaths = [];
            const currentPath = [];

            function dfs(currentId) {
                // Add the current node to the path
                currentPath.push(currentId);

                // If we reached the target, record the current path
                if (currentId === targetId) {
                    // Make a copy since `currentPath` is mutable
                    allPaths.push([...currentPath]);
                } else {
                    // Otherwise, continue DFS on each child
                    const children = adjacency[currentId] || [];
                    for (let childId of children) {
                        // Avoid re-visiting a node in the current path if you want strictly simple paths
                        if (!currentPath.includes(childId)) {
                            dfs(childId);
                        }
                    }
                }

                // Backtrack
                currentPath.pop();
            }

            // Start DFS from sourceId
            dfs(sourceId);
            return allPaths;
        }

        /**
         * Helper to build a map of nodeId -> array of child nodeIds from the given links.
         */
        function buildAdjacencyMap(nodes, links) {
            const adjacency = {};
            // Initialize adjacency list for each node
            nodes.forEach(n => {
                adjacency[n.id] = [];
            });

            // Populate adjacency
            links.forEach(link => {
                // We'll assume link.source.id and link.target.id exist
                const parentId = link.source.id;
                const childId = link.target.id;
                adjacency[parentId].push(childId);
            });
            return adjacency;
        }

        /**
         * Given an array of `nodes`, resets each node's `visitCount` to 0 (or creates it if missing).
         */
        function resetNodeVisits(nodes) {
            nodes.forEach(node => {
                node.visitCount = 0;
            });
        }

        /**
         * Given a list of paths (each path is an array of node IDs),
         * increments `visitCount` for each node on each path.
         * Assumes `nodes` is an array of node objects each accessible by ID.
         */
        function incrementNodeVisitsForPaths(paths, nodes) {
            // For fast lookup: build a map of nodeId -> node object
            const nodeMap = {};
            nodes.forEach(n => {
                nodeMap[n.id] = n;
            });

            // For each path and for each nodeId in that path, increment visitCount
            paths.forEach(path => {
                path.forEach(nodeId => {
                    nodeMap[nodeId].visitCount++;
                });
            });
        }

        /***************************************************************
         * 2) PAGE SETUP & GLOBAL VARIABLES
         ***************************************************************/
        let { svgWidth, svgHeight } = adjustSVGHeight();
        const svg = d3.select("svg");
        const g = svg.append("g");

        // Node & link style presets
        const NODE_STYLES = {
            selected: {
                r: 6,
                "fill-opacity": 1,
                "stroke": "black",
                "stroke-width": 4,
                "stroke-opacity": 1
            },
            spine: {
                r: 6,
                "fill-opacity": 1,
                "stroke": "green",
                "stroke-width": 2,
                "stroke-opacity": 1
            },
            source: {
                r: 10,
                "fill-opacity": 1,
                "stroke": "gold",
                "stroke-width": 2,
                "stroke-opacity": 1
            },
            target: {
                r: 10,
                "fill-opacity": 1,
                "stroke": "gold",
                "stroke-width": 2,
                "stroke-opacity": 1
            },
            choice_in: {
                r: 8,
                "fill-opacity": 1,
                "stroke": "black",
                "stroke-width": 6,
                "stroke-opacity": 0.3,
                "choice": 1
            },
            choice_out: {
                r: 10,
                "fill-opacity": 1,
                "stroke": "gold",
                "stroke-width": 6,
                "stroke-opacity": 0.5,
                "choice": 1
            },
            revealed: {
                r: 5,
                "fill-opacity": 0.3,
                "stroke": "black",
                "stroke-width": 1,
                "stroke-opacity": 0.2
            },
            pool: {
                r: 5,
                "fill-opacity": 0.1,
                "stroke": "none",
                "choice": 0
            }
        };

        const LINK_STYLES = {
            spine: {
                "stroke": "black",
                "stroke-width": 2,
                "stroke-opacity": 0.8
            },
            spineadjacent: {
                "stroke": "black",
                "stroke-width": 5,
                "stroke-opacity": 0.3
            },
            general: {
                "stroke": "gold",
                "stroke-width": 5,
                "stroke-opacity": 0.5
            },
            choice_in: {
                "stroke": "black",
                "stroke-width": 3,
                "stroke-opacity": 0.5
            },
            choice_out: {
                "stroke": "gold",
                "stroke-width": 3,
                "stroke-opacity": 0.5
            },
            pool: {
                "stroke": "white",
                "stroke-opacity": 0
            }
        };

        // Placeholders for data and force simulation references
        let nodes, links, simulation;
        let link, node;

        // For removed data tracking
        let removedNodes = new Map();
        let removedLinks = new Map();

        /***************************************************************
         * 3) LOAD JSON DATA & INITIALIZE THE FORCE SIMULATION
         ***************************************************************/

        const sourceId = 1;
        const targetId = 186;

        d3.json("mgpdata.json").then(graphData => {
            nodes = graphData.nodes;
            links = graphData.links;

            // Initialize hidden and highlight states
            nodes.forEach((n, i) => {
                n.hidden = false;
                n.year = n.y;
                n.spine = 0;
                n.choice = 0;
                n.spineheld = 0;
                n.fixedY = svgHeight - ((n.y - 1660) / (2005 - 1660)) * svgHeight;
                n.fixedY = Math.max(10, Math.min(svgHeight - 10, n.fixedY));

                // Fix the first node in the center
                if (i === sourceId-1) {
                    n.fx = svgWidth / 2;

                    n.spine = 1;
                    n.spineheld = 1;
                }
                if (i === targetId-1) {
                    n.fx = svgWidth / 2;

                    n.spine = 1;
                    n.spineheld = 1;
                }
            });

            links.forEach(l => {
                l.hidden = false;
                l.highlighted = false;
                l.highlightColor = null;
            });

            let linkDistance = 100;
            let chargeStrength = 0;
            let collisionRadius = 50;

            // Create the force simulation
            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links).id(d => d.id).distance(linkDistance))
                .force("charge", d3.forceManyBody().strength(chargeStrength))
                .force("collision", d3.forceCollide().radius(collisionRadius))
                .on("tick", ticked);
            

            // Create link elements
            link = g.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter()
                .append("line")
                .attr("class", "link")
                .attr("stroke", "red")
                .attr("stroke-opacity", 0.0)
                .attr("spineheld", 0);

            // Create node groups
            node = g.append("g")
                .attr("class", "nodes")
                .attr("choice", 0)
                .selectAll("g")
                .data(nodes)
                .enter()
                .append("g")
                .attr("r", 5)
                .attr("class", "node")
                .attr("fill-opacity", 0.2)
                .attr("stroke-opacity", 0.2);

            // Generate spine data (currently using hardcoded ids, this should change to prompt user to pick from all nodes from a dropdown)

            // Indicate key nodes
            d3.selectAll(".node")
                .filter(n => n.id === sourceId)
                .select("circle")
                .attr("r", 15)
                .attr("fill-opacity", 0.898)
                .attr("stroke-opacity", 1);
            //applyNodeStyle(sourceId, "source");
            //applyNodeStyle(targetId, "target");

            // Drag behavior
            const drag = d3.drag()
                .on("start", dragStarted)
                .on("drag", dragged)
                .on("end", dragEnded);

            node.call(drag);

            // Append circles to node groups
            node.append("circle")
                .attr("r", 5)
                .attr("fill", d => d.color)
                .on("mouseover", handleMouseOver)
                .on("mousemove", handleMouseMove)
                .on("mouseout", handleMouseOut);

            // Node click
            node.on("click", handleNodeClick);

            // Node dblclick
            node.on("dblclick", handleNodeDblClick);

            // Reset formatting when clicking empty space (optional)
            svg.on("click", () => {
                // resetFormatting();
            });

            // Slider input listeners
            d3.select("#linkDistance").on("input", function () {
                linkDistance = +this.value;
                d3.select("#linkDistanceValue").text(linkDistance);
                simulation.force("link", d3.forceLink(links).id(d => d.id).distance(linkDistance));
                simulation.alpha(1).restart();
            });

            d3.select("#chargeStrength").on("input", function () {
                chargeStrength = +this.value;
                d3.select("#chargeStrengthValue").text(chargeStrength);
                simulation.force("charge", d3.forceManyBody().strength(chargeStrength));
                simulation.alpha(1).restart();
            });

            d3.select("#collisionRadius").on("input", function () {
                collisionRadius = +this.value;
                d3.select("#collisionRadiusValue").text(collisionRadius);
                simulation.force("collision", d3.forceCollide().radius(collisionRadius));
                simulation.alpha(1).restart();
            });
        }).catch(error => console.error(error));

        /***************************************************************
         * 4) EVENT HANDLERS
         ***************************************************************/

        /**
         * Mouseover event handler to show tooltips.
         */
        function handleMouseOver(event, d) {
            if (d.spineheld === 1 || d.choice == 1) {
                d3.select(".tooltip")
                    .style("visibility", "visible")
                    .style("top", `${event.pageY + 10}px`)
                    .style("left", `${event.pageX + 10}px`)
                    .html(`<strong>${d.name}</strong><br>${d.tooltip}`);
            }
        }

        /**
         * Mousemove event handler to move tooltips.
         */
        function handleMouseMove(event) {
            d3.select(".tooltip")
                .style("top", `${event.pageY + 10}px`)
                .style("left", `${event.pageX + 10}px`);
        }

        /**
         * Mouseout event handler to hide tooltips.
         */
        function handleMouseOut() {
            d3.select(".tooltip").style("visibility", "hidden");
        }

        /**
         * Click event handler for nodes.
         */
        function handleNodeClick(event, d) {
            

            if (d.spineheld === 0) {
                // Possibly re-position node if not yet spineheld
                setNodeXPosition(d, nodes, links, 200, 20);
            }

            d.spineheld = 1;
            resetFormatting();
            // Append text to node
            d3.selectAll(".node")
                .filter(n => n.id === d.id)
                .append("text")
                .attr("x", 9)
                .attr("y", 3)
                .text(n => n.name)
                .attr("fill", "black")
                .attr("fill-opacity", 1)
                .style("font-size", "12px")
                .style("font-weight", "bold");

            // Highlight the clicked node
            d3.selectAll(".node")
                .filter(n => n.id === d.id)
                .select("circle")
                .attr("r", 7)
                .attr("fill-opacity", 0.898)
                .attr("stroke-opacity", 1);

            applyNodeStyle(d.id, "selected");

            // Incoming/outgoing highlighting
            const visitedIncoming = new Set();
            highlightIncoming(d.id, visitedIncoming);

            const visitedOutgoing = new Set();
            highlightOutgoing(d.id, visitedOutgoing);

            // Update text box
            const incomingLinks = links
                .filter(link => link.target.id === d.id)
                .map(link => `${link.source.id} (${Math.round(link.source.y)}) (A)`);

            const outgoingLinks = links
                .filter(link => link.source.id === d.id)
                .map(link => `${link.target.id} (${Math.round(link.target.y)}) (S)`);

            const textBoxContent = `
            <strong>Name:</strong> ${d.name}<br>
            <strong>Year:</strong> ${Math.round(d.year)}<br>
            <strong>Connected Nodes:</strong> ${[...incomingLinks, ...outgoingLinks].join(' ') || 'None'}<br>
            <strong>Summary:</strong> ${d.tooltip}
          `;
            d3.select("#textBox").html(textBoxContent);
        }

        /**
         * Double-click event handler for nodes.
         */
        function handleNodeDblClick(event, d) {
            resetFormatting();

            d.fx = null;
            d.spineheld = 1;

            d3.selectAll(".node")
                .filter(n => n.id === d.id)
                .select("circle")
                .attr("r", 7)
                .attr("fill-opacity", 0.2)
                .attr("stroke-opacity", 0.2);

            d3.selectAll(".node")
                .filter(n => n.id === d.id)
                .selectAll("text")
                .remove();

            const visitedIncoming = new Set();
            highlightIncomingDbl(d.id, visitedIncoming);

            const visitedOutgoing = new Set();
            highlightOutgoingDbl(d.id, visitedOutgoing);

            const incomingLinks = links
                .filter(link => link.target.id === d.id)
                .map(link => `${link.source.id} (${Math.round(link.source.y)}) (A)`);

            const outgoingLinks = links
                .filter(link => link.source.id === d.id)
                .map(link => `${link.target.id} (${Math.round(link.target.y)}) (S)`);

            const textBoxContent = `
            <strong>Name:</strong> ${d.name}<br>
            <strong>Year:</strong> ${Math.round(d.year)}<br>
            <strong>Connected Nodes:</strong> ${[...incomingLinks, ...outgoingLinks].join(' ') || 'None'}<br>
            <strong>Summary:</strong> ${d.tooltip}
          `;
            d3.select("#textBox").html(textBoxContent);
        }

        /**
         * Highlights incoming links/nodes on click.
         */
        function highlightIncoming(nodeId, visitedIncoming) {
            if (visitedIncoming.has(nodeId)) return;
            visitedIncoming.add(nodeId);

            links.forEach(link => {
                if (link.target.id === nodeId) {
                    link.highlighted = true;
                    link.highlightColor = "red";
                    applyLinkStyle(link, "choice_in");

                    link.source.choice = 1;

                    d3.selectAll(".node")
                        .filter(n => n.id === link.source.id && link.source.spineheld === 0)
                        .select("circle")
                        .attr("r", 10)

                    applyNodeStyle(link.source.id, "choice_in");
                }
            });
        }

        /**
         * Highlights outgoing links/nodes on click.
         */
        function highlightOutgoing(nodeId, visitedOutgoing) {
            if (visitedOutgoing.has(nodeId)) return;
            visitedOutgoing.add(nodeId);

            links.forEach(link => {
                if (link.source.id === nodeId) {
                    link.highlighted = true;
                    link.highlightColor = "blue";
                    if (link.target.spineheld === 0) {
                        applyLinkStyle(link, "choice_out");
                    }
                    link.target.choice = 1;


                    d3.selectAll(".node")
                        .filter(n => n.id === link.target.id && link.target.spineheld === 0)

                    applyNodeStyle(link.target.id, "choice_out");
                }
            });
        }

        /**
         * Highlights incoming links/nodes on double-click.
         */
        function highlightIncomingDbl(nodeId, visitedIncoming) {
            if (visitedIncoming.has(nodeId)) return;
            visitedIncoming.add(nodeId);

            links.forEach(link => {
                if (link.target.id === nodeId) {
                    link.highlighted = false;
                    link.highlightColor = "red";

                    d3.selectAll(".node")
                        .filter(n => n.id === link.source.id)
                        .select("circle")
                        .attr("r", 10);
                }
            });
        }

        /**
         * Highlights outgoing links/nodes on double-click.
         */
        function highlightOutgoingDbl(nodeId, visitedOutgoing) {
            if (visitedOutgoing.has(nodeId)) return;
            visitedOutgoing.add(nodeId);

            links.forEach(link => {
                if (link.source.id === nodeId) {
                    link.highlighted = false;
                    link.highlightColor = "blue";

                    d3.selectAll(".node")
                        .filter(n => n.id === link.target.id)
                        .select("circle")
                        .attr("r", 10);

                    d3.selectAll(".node")
                        .filter(n => n.id === link.target.id)
                        .select("text");
                }
            });
        }

        /**
         * Reset all formatting, skipping links with both ends spineheld=1.
         */
        function resetFormatting() {
            links.forEach(l => {
                if (l.source.spineheld === 1 && l.target.spineheld === 1) {
                    applyLinkStyle(l, "spine");

                }
                if (l.source.spineheld === 0 || l.target.spineheld === 0){
                    applyLinkStyle(l, "pool");
                    //l.highlighted = false;
                    //l.highlightColor = null;

                }
            });

            d3.selectAll(".link")
                .filter(l => ((l.source.spineheld === 0 || l.target.spineheld === 0)))
                .attr("stroke", "green");


            nodes.forEach(resetnode => {
                if (resetnode.id === sourceId) {
                    applyNodeStyle(resetnode.id, "source");
                }
                else if (resetnode.id === targetId) {
                    applyNodeStyle(resetnode.id, "target");
                }
                else if (resetnode.spineheld === 0) {
                    applyNodeStyle(resetnode.id, "pool");
                }
                else if (resetnode.spineheld === 1) {
                    applyNodeStyle(resetnode.id, "selected");
                }
            });

            // Example of commented-out code left intact:
            // d3.selectAll(".link").attr("stroke-opacity", 0);
            // d3.selectAll(".node circle").attr("stroke", "none");
        }

        /***************************************************************
         * 5) DRAG & TICK HANDLERS
         ***************************************************************/

        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x; // Fix x for dragging
        }

        function dragged(event, d) {
            d.fx = Math.max(10, Math.min(svgWidth - 10, event.x));
            d.x = d.fx;
        }

        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = d.x;
            d.fx = Math.round(d.x / 200) * 200;
        }

        /**
         * The simulation's "tick" handler for positioning.
         */
        function ticked() {
            // Constrain each node's x within the SVG width
            nodes.forEach(d => {
                d.x = Math.max(10, Math.min(svgWidth - 10, d.x));
            });

            link
                .attr("x1", d => d.source.x)
                .attr("y1", d => d.source.fixedY)
                .attr("x2", d => d.target.x)
                .attr("y2", d => d.target.fixedY)
                // .attr("stroke", d => d.highlighted ? d.highlightColor : "#999") // commented from original
                // .attr("stroke-width", d => d.highlighted ? 3 : 1.5)
                // .attr("stroke-opacity", d => d.highlighted ? 1 : 0.2);

            node
                .attr("transform", d => `translate(${d.x},${d.fixedY})`);
        }

        /***************************************************************
         * 6) REMOVE/RESTORE DESCENDANTS & RESTART SIM
         ***************************************************************/

        function removeDescendants(node) {
            const descendants = new Set();
            const linksToRemove = [];
            const nodesToRemove = [];

            function findDescendants(nodeId) {
                links.forEach(link => {
                    if (link.source.id === nodeId) {
                        descendants.add(link.target.id);
                        linksToRemove.push(link);
                        findDescendants(link.target.id);
                    }
                });
            }

            findDescendants(node.id);

            descendants.forEach(descendantId => {
                const descendantNode = nodes.find(n => n.id === descendantId);
                if (descendantNode) nodesToRemove.push(descendantNode);
            });

            removedNodes.set(node.id, nodesToRemove);
            removedLinks.set(node.id, linksToRemove);

            nodes.splice(0, nodes.length, ...nodes.filter(n => !descendants.has(n.id)));
            links.splice(0, links.length, ...links.filter(l => !linksToRemove.includes(l)));
        }

        function restoreDescendants(node) {
            const nodesToRestore = removedNodes.get(node.id) || [];
            const linksToRestore = removedLinks.get(node.id) || [];

            nodes.push(...nodesToRestore);
            links.push(...linksToRestore);

            removedNodes.delete(node.id);
            removedLinks.delete(node.id);
        }

        function restartSimulation() {
            link = g.selectAll(".link")
                .data(links, d => `${d.source.id}-${d.target.id}`);
            link.exit().remove();
            link.enter()
                .append("line")
                .attr("class", "link")
                .merge(link);

            node = g.selectAll(".node")
                .data(nodes, d => d.id);
            node.exit().remove();

            const nodeEnter = node.enter()
                .append("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragStarted)
                    .on("drag", dragged)
                    .on("end", dragEnded)
                );

            nodeEnter.append("circle")
                .attr("r", 5)
                .attr("fill", d => d.color);

            node = nodeEnter.merge(node);

            simulation.nodes(nodes);
            simulation.force("link").links(links);
            simulation.alpha(1).restart();
        }
    </script>
</body>
</html>
